<!DOCTYPE html>
<html lang="en" class="ms-bg">
<head>
    <meta charset="utf-8">
    <title>Mostly Security - Episodes</title>
    <meta name="description" content="Mostly Security Episodes">
    <meta name="author" content="Mostly Security">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../normalize.css">
    <link rel="stylesheet" href="../skeleton.css">
    <link rel="stylesheet" href="../mostlysecurity.css">
    <link rel="stylesheet" href="episode.css">
    <link rel="apple-touch-icon" sizes="57x57" href="../favicons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../favicons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../favicons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../favicons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../favicons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../favicons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../favicons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../favicons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../favicons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="../favicons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicons/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#232323">
    <meta name="msapplication-TileImage" content="../favicons/ms-icon-144x144.png">
    <meta name="theme-color" content="#232323">

    
</head>
<body class="ms-body ms-body-episodes" id="top">
    <div class="container main-container">
        
        <div class="row header">
            <div class="twelve columns" id="podcast-info-wrapper">
                <!-- Podcast info will be rendered here -->
            </div>
        </div>

        <div class="row header">
            <div class="twelve columns">
                <div id="episodes-container">
                    <!-- Episode cards will be inserted here -->
                </div>
                <div id="loader" class="is-idle"></div>
                <div id="message-box"></div>
                <a href="#top" id="back-to-top" class="back-link back-to-top">Back to top</a>
            </div>
        </div>
        <div class="row header">
            <div class="twelve columns">
                <a href="/" class="back-link">&larr; Back to Home</a>
            </div>
        </div>
    </div>

    <script>
        const loader = document.getElementById('loader');
        const episodesContainer = document.getElementById('episodes-container');
        const podcastInfoWrapper = document.getElementById('podcast-info-wrapper');
        const messageBox = document.getElementById('message-box');
        const backToTop = document.getElementById('back-to-top');
        const batchSize = 5;
        let allItems = [];
        let nextIndex = 0;
        let isAppending = false;
        let observer = null;

        document.addEventListener('DOMContentLoaded', handleRenderClick);
        
        async function handleRenderClick() {
            // const rssUrl = "https://rss.mostlysecurity.com/";
            const rssUrl = "https://feeds.libsyn.com/121466/rss";
            const params = new URLSearchParams(window.location.search);
            const episodeParam = params.get('e');
            const episodeNumber = episodeParam ? parseInt(episodeParam, 10) : null;
            const hasEpisodeFilter = Number.isFinite(episodeNumber);
 
            // Reset UI
            setLoadingState(true);
            episodesContainer.innerHTML = '';
            podcastInfoWrapper.innerHTML = '';
            messageBox.innerHTML = '';
            setBackToTopVisible(false);
            
            try {
                let response = await fetch(rssUrl, { redirect: 'follow' });

                // If the initial fetch was a redirect, get the text from the final URL
                // This handles cases where the initial RSS URL redirects to another RSS URL
                if (response.redirected) {
                    response = await fetch(response.url);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const str = await response.text();
                const data = new window.DOMParser().parseFromString(str, "text/xml");
                
                displayPodcastInfo(data);

                allItems = Array.from(data.querySelectorAll("item"));
                if (allItems.length === 0) {
                    showMessage('No episodes found in this feed.');
                    setBackToTopVisible(false);
                } else {
                    if (hasEpisodeFilter) {
                        const match = allItems.find((item) => getEpisodeNumber(item) === episodeNumber);
                        if (match) {
                            renderEpisode(match, 0);
                            showMessage('');
                        } else {
                            showMessage('Episode not found.');
                        }
                        setLoadingState(false);
                    } else {
                        nextIndex = 0;
                        setLoadingState(false);
                        setupInfiniteScroll();
                        loadNextBatch();
                    }
                }

            } catch (error) {
                console.error("Error fetching or parsing RSS feed:", error);
                showMessage('Failed to fetch or parse the RSS feed. Please check the URL and try again.');
            } finally {
                setLoadingState(false);
            }
        }

        function displayPodcastInfo(data) {
            const title = data.querySelector("channel > title")?.textContent || 'No title found';
            const description = data.querySelector("channel > description")?.textContent || 'No description available.';
            const imageUrl = data.querySelector("channel > image > url")?.textContent;

            let imageHtml = '';
            if (imageUrl) {
                imageHtml = `<img src="${imageUrl}" alt="${title} cover art" class="podcast-image">`;
            }
            
            podcastInfoWrapper.innerHTML = `
                <div class="bgshade black">
                    <div class="podcast-info-container">
                        ${imageHtml}
                        <!-- <strong class="title">${title}</strong> -->
                        <p>${description}</p>
                    </div>
                </div>
            `;
        }

        function renderEpisode(item, index) {
            let color = 'black';
            if (index) {
                const colors = ['purple', 'green', 'orange', 'red'];
                color = colors[index % colors.length];
            }

            const title = item.querySelector("title")?.textContent || 'No title';
            const pubDate = item.querySelector("pubDate")?.textContent ? new Date(item.querySelector("pubDate").textContent).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : 'No date';
            const descriptionNode = item.querySelector("description");
            const duration = item.querySelector("duration")?.textContent || '';
            const descriptionHtml = descriptionNode?.textContent || '<p>No description available.</p>';

            const enclosure = item.querySelector("enclosure");
            const mp3Url = enclosure?.getAttribute('url');
            let downloadLinkHtml = '';
            if (mp3Url) {
                downloadLinkHtml = `<a href="${mp3Url}" download>Download</a>`;
            }

            const card = document.createElement('div');
            card.className = `bgshade ${color}`;
            card.innerHTML = `
                <strong class="episode">${title}</strong>
                <div class="episode-date">${pubDate}</div>
                <div class="episode-length">${duration ? `Time: ${duration} &nbsp;&nbsp;` : ''} ${downloadLinkHtml}</div>
                <div class="episode-description">${descriptionHtml}</div>
                <audio controls preload="none" src="${mp3Url}"></audio>
            `;
            episodesContainer.appendChild(card);
        }

        function loadNextBatch() {
            if (isAppending) {
                return;
            }

            if (nextIndex >= allItems.length) {
                showMessage('End of episodes.');
                setBackToTopVisible(true);
                if (observer) {
                    observer.disconnect();
                }
                setLoadingState(false);
                return;
            }

            isAppending = true;
            setLoadingState(true);

            const slice = allItems.slice(nextIndex, nextIndex + batchSize);
            slice.forEach((item, index) => renderEpisode(item, nextIndex + index));
            nextIndex += slice.length;

            isAppending = false;
            setLoadingState(false);

            if (nextIndex >= allItems.length) {
                showMessage('End of episodes.');
                setBackToTopVisible(true);
                if (observer) {
                    observer.disconnect();
                }
            } else {
                showMessage('');
                setBackToTopVisible(false);
            }
        }

        function setupInfiniteScroll() {
            if (observer) {
                observer.disconnect();
            }

            if ('IntersectionObserver' in window) {
                observer = new IntersectionObserver((entries) => {
                    if (entries.some((entry) => entry.isIntersecting)) {
                        loadNextBatch();
                    }
                }, { root: null, rootMargin: '200px' });
                observer.observe(loader);
            } else {
                window.addEventListener('scroll', handleScrollFallback);
            }
        }

        function handleScrollFallback() {
            const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 200;
            if (nearBottom) {
                loadNextBatch();
            }
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                loader.textContent = 'Loading more episodes...';
                loader.classList.remove('is-idle');
            } else {
                loader.textContent = '';
                loader.classList.add('is-idle');
            }
        }

        function showMessage(message) {
            messageBox.innerHTML = message;
        }

        function setBackToTopVisible(isVisible) {
            if (isVisible) {
                backToTop.classList.add('is-visible');
            } else {
                backToTop.classList.remove('is-visible');
            }
        }

        function getEpisodeNumber(item) {
            const itunesNumber = item.querySelector("itunes\\:episode, episode")?.textContent;
            if (itunesNumber) {
                const parsed = parseInt(itunesNumber, 10);
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
            }

            const title = item.querySelector("title")?.textContent || '';
            const match = title.match(/\b(?:ep(?:isode)?\s*)?(\d{1,4})\b/i);
            if (match) {
                const parsed = parseInt(match[1], 10);
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
            }

            return null;
        }

    </script>
</body>
</html>
